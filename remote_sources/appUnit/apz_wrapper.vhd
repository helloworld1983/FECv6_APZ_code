--------------------------------------------------------------
--------------------------------------------------------------
--                                                          --
-- This VHDL file has been generated by the verilog2vhdl    --
-- tool.                                                    --
-- Contact help@edautils.com  for support/info.--
--                                                          --
--                                                          --
--------------------------------------------------------------
--------------------------------------------------------------
--
--
-- Assumptions: 
--         (1) All the parameters are of type INTEGER, and hence the translated generics are of this type
--
--
-- Generated by : smartoiu on 04/04/12 22:46
--
--


library ieee;
use ieee.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use ieee.numeric_std.all;
library work;
use work.vhdl_functions_sc.all;
--library work;
use work.api_pack.all;

entity apz_wrapper is 
     port (
        clk, clk10M, clk125 :  in std_logic;
        rstn                :  in std_logic;
        regs                :  in std_logic_vector( 1023  downto 0  );
        trigger             :  in std_logic;
        -- apv_data         : in  array16x12;
        apv_data            : in  std_logic_vector(191 downto 0);
		  
        api_data_out      :  out std_logic_vector( 255  downto 0  );
        api_wordcount_out :  out std_logic_vector( 255  downto 0  );
        api_ready_out     :  out std_logic_vector( 15  downto 0  );
        api_output_enable :  in std_logic_vector( 15  downto 0  );
        api_read_in       :  in std_logic_vector( 15  downto 0  );
		  
        api_I2C_request :  out std_logic;
        api_I2C_done    :  in std_logic;
        api_I2C_ctr2    :  out std_logic_vector( 4  downto 0  );
        api_sigped_apv  :  in std_logic_vector( 3  downto 0  );
		  
        api_load_pedestal :  in std_logic;
        api_load_sigma    :  in std_logic;
        api_pedestal_addr :  in std_logic_vector( 6  downto 0  );
        api_sigma_addr    :  in std_logic_vector( 6  downto 0  );
        api_pedestal_in   :  in std_logic_vector( 11  downto 0  );
        api_sigma_in      :  in std_logic_vector( 11  downto 0  );
        api_pedestal_out  :  out std_logic_vector( 11  downto 0  );
        api_sigma_out     :  out std_logic_vector( 11  downto 0  );
		  
        apz_status          :  out std_logic_vector(15  downto 0  );
        apz_chstatus        :  out std_logic_vector(31  downto 0  );
        evbld_apz           :  out std_logic;
        api_reset           :  out std_logic;
        api_random_trigger  :  out std_logic;
        api_trigger_inhibit :  out std_logic;
        api_busy_out 		 :  out std_logic;
        api_apv_select      :  out std_logic_vector( 3  downto 0  )
    );
end entity; 


architecture rtl of apz_wrapper is 
    signal cfg_roenable            : std_logic_vector( 7  downto 0  );
    signal cfg_bclk_trgburst       : std_logic_vector( 7  downto 0  );
    signal cfg_evbld_chmask        : std_logic_vector( 15  downto 0  );
    signal cfg_apz_cmd             : std_logic_vector( 7  downto 0  );
    signal cfg_apz_apvselect       : std_logic_vector( 7  downto 0  );
    signal cfg_apz_nsamples        : std_logic_vector( 7  downto 0  );
    signal cfg_apz_zerosuppression : std_logic_vector( 31  downto 0  );
    signal cfg_apz_threshold       : std_logic_vector( 15  downto 0  );
    signal cfg_apz_zsparams        : std_logic_vector( 15  downto 0  );
	 
    signal api_random_trigger_i, evbld_apz_i    : std_logic;
    signal api_trigger_inhibit_i   : std_logic;
    signal api_reset_i, reset_cmd  : std_logic;
    signal api_apv_select_i        : std_logic_vector( 3  downto 0  );
	 
    signal api_pedestal_wd_flag : std_logic;
    signal api_trigger_in       : std_logic;
    signal api_start_calib      : std_logic;
    signal api_busy             : std_logic;
    signal api_resync           : std_logic;
    signal api_phase_aligned    : std_logic;
    signal api_n_samples        : std_logic_vector( 4  downto 0  );
    signal api_apv_mask, api_flush_data, api_read         : std_logic_vector( 15  downto 0  );
    signal api_n_samples_tmp    : std_logic_vector( 7  downto 0  );
    signal api_start_calib_r    : std_logic_vector( 1  downto 0  );
	 
	 
COMPONENT APV_Interface_multi_wrap
Port (     clk : in  STD_LOGIC; 
           clk125 : in  STD_LOGIC;
			  clk10 : in  STD_LOGIC; 
           reset : in  STD_LOGIC;
           
			  cfg_zs: in STD_LOGIC_VECTOR (31 downto 0) := x"00000000";

           apv_select : in std_logic_vector(3 downto 0);
			  apv_mask : in std_logic_vector(15 downto 0);
           -- apv_data : in  array16x12;
           apv_data : in  std_logic_vector(191 downto 0);
			  
			  -- system trigger, not the APV trigger
			  trigger_in : in std_logic;
			  
			  -- n.of time bins per trigger 
			  n_samples : in  STD_LOGIC_VECTOR (LOG2_MAX_SAMPLES-1 downto 0);
			  
			  -- processed data out
			  read_in        : in   STD_LOGIC_VECTOR (15 downto 0);  
			  output_enable  : in   STD_LOGIC_VECTOR (15 downto 0); 
			  data_out       : out  std_logic_vector(255 downto 0); 
			  ready_out      : out  STD_LOGIC_VECTOR (15 downto 0);  
           wordcount_out  : out  std_logic_vector(255 downto 0); 
			  			  
			  -- pedestal calculation
			  start_calib : in  STD_LOGIC;                     -- set high for 1 clock cycle, to start autoset    
			  busy : out  STD_LOGIC; 
			  pedestal_wd_flag : out std_logic;
			  
			  -- pedestal filereg access, meant to be driven by Slow Control
			 filereg_apvselect : in  STD_LOGIC_VECTOR (3 downto 0);
			 load_pedestal : in  STD_LOGIC;                        -- load pedestal_in value into pedestal reg 
          pedestal_addr : in  STD_LOGIC_VECTOR (6 downto 0);
			 pedestal_in   : in  STD_LOGIC_VECTOR (11 downto 0);   -- external pedestal input 
          pedestal_out  : out  STD_LOGIC_VECTOR (11 downto 0);   -- current pedestal setting
			  
			 load_sigma    : in  STD_LOGIC;
			 sigma_in      : in  STD_LOGIC_VECTOR (11 downto 0);
			 sigma_addr    : in  STD_LOGIC_VECTOR (6 downto 0);			  
			 sigma_out     : out  STD_LOGIC_VECTOR (11 downto 0);   -- pedestal st.dev

  		    random_trigger : out  STD_LOGIC;
			  
			  
			  -- TPLL phase manging signals
			  resync: in  STD_LOGIC;
			  trigger_inhibit : out  STD_LOGIC;      
           phase_aligned : out  STD_LOGIC; 
			  I2C_request : out  STD_LOGIC;
           I2C_done : in  STD_LOGIC;
           I2C_ctr2 : out  STD_LOGIC_VECTOR (4 downto 0)
			  );
END COMPONENT;

    begin 
        cfg_roenable            <= ireg8( 15 , regs );
        cfg_bclk_trgburst       <= ireg8( 1 , regs );
        cfg_evbld_chmask        <= ireg16( 8 , regs );
		  -- 17 RESERVED
        cfg_apz_apvselect       <= ireg8( 18 , regs );
        cfg_apz_nsamples        <= ireg8( 19 , regs );
        cfg_apz_threshold		  <= ireg16( 20 , regs );
        cfg_apz_zsparams 		  <= ireg16( 21 , regs );
		  
        cfg_apz_cmd             <= ireg8( 31 , regs );
		  
		  cfg_apz_zerosuppression <= cfg_apz_zsparams & cfg_apz_threshold;
        
        api_n_samples_tmp    <= ( cfg_bclk_trgburst + cfg_bclk_trgburst  + cfg_bclk_trgburst + 3 ) when ( cfg_apz_nsamples = X"00"  ) else cfg_apz_nsamples ;
        api_n_samples        <= api_n_samples_tmp(4  downto 0 );
		  
--        api_reset_i          <= ( ( (  not rstn )  or (not evbld_apz_i) )  or reset_cmd ) ;
		  api_reset            <= api_reset_i;
		  evbld_apz				  <= evbld_apz_i;
		  
-------------------------------------------------------------------------------------------------------------------------------------------------------
--                                                                   APZ COMMAND FSM                                                                 --
-------------------------------------------------------------------------------------------------------------------------------------------------------
	cmd_fsm_block: block
		signal api_busy_r, cmd_done, reset_after_cal: std_logic;
		signal cmd_apv_sel		     : std_logic_vector( 4  downto 0  );
		signal api_apv_select_r : std_logic_vector(3 downto 0) := "0000";
		signal cfg_apz_cmd_r : std_logic_vector(7 downto 0) := "00000000";
		alias cfg_apz_cmd1 : std_logic_vector(3 downto 0) is cfg_apz_cmd(3 downto 0);
		alias cfg_apz_cmd2 : std_logic_vector(3 downto 0) is cfg_apz_cmd(7 downto 4);
		
		type cmd_state_type is (stIdle, stPhaseCalib, stPedCalib0, stPedCalib1, stFlushData, stValidateCh, stBypass, stBypassEnd, stAPZReset, stCmdDone);
		signal state: cmd_state_type;
	begin
	  cmd_fsm: process (clk)
	  variable counter :std_logic_vector(15 downto 0) := x"0000";
	  begin
			if ( clk'EVENT and ( clk = '1' )  ) then
				if ( ( rstn = '0' )  ) then 
					state <= stIdle;
					cmd_apv_sel <= (others => '0');
					cfg_apz_cmd_r <= (others => '0');
					apz_chstatus <= (others => '0');
					counter := x"0000";
					reset_after_cal <= '0';
				else
					reset_after_cal <= '0';
					if state = stIdle then
						cmd_apv_sel <= (others => '0');
						counter := x"0000";
						if 	cfg_apz_cmd = 1 then			state		<= stPhaseCalib;				-- phase calibration
						elsif cfg_apz_cmd = 2 then			state		<= stPedCalib0;				-- pedestal calibration
						elsif cfg_apz_cmd = 3 then			state		<= stPhaseCalib;				-- "full calibration" (phase and pedestal, single channel)
						elsif cfg_apz_cmd = 15 then		state		<= stBypass;					-- bypass one channel
						elsif cfg_apz_cmd2 = 1 then		state		<= stValidateCh;				-- "calibrate all"	(phase and/or pedestal, all channels in chmask)
																	apz_chstatus <= (others => '0');
						elsif cfg_apz_cmd = 255 then		state		<= stAPZReset;					-- reset zs code
						end if;
						cfg_apz_cmd_r <= cfg_apz_cmd;
					-------------------------------------------------------------------------------------------------------	
					elsif state = stPhaseCalib then
						if cfg_apz_cmd = 0 then				state 	<= stIdle;
						elsif api_phase_aligned = '1' then
							if cfg_apz_cmd = 3 then			state 	<= stPedCalib0;				-- if "full calibration" go to pedestal calibration
							elsif cfg_apz_cmd2 = 1 then
								if cfg_apz_cmd1 = 1 then 	state 	<= stValidateCh;				-- if "calibrate all" command (phase only), test next channel
																	cmd_apv_sel <= cmd_apv_sel + 1;
								else								state 	<= stPedCalib0;				-- if "calibrate all" go to pedestal calibration
								end if;
							else									state 	<= stCmdDone;					-- otheriwise return to idle
							end if;
						end if;
					-------------------------------------------------------------------------------------------------------	
					elsif state = stPedCalib0 then 		state 	<= stPedCalib1;				-- start calibration
					-------------------------------------------------------------------------------------------------------	
					elsif state = stPedCalib1 then
						if cfg_apz_cmd = 0 then				state 	<= stFlushData;
						elsif api_busy = '0' then			state 	<= stFlushData;				-- wait for calibration to end, flush remaining data
							apz_chstatus(conv_integer(api_apv_select_i)) <= not api_pedestal_wd_flag;
						end if;
					-------------------------------------------------------------------------------------------------------	
					elsif state = stFlushData then
						if cfg_apz_cmd = 0 then				state 	<= stIdle;
						elsif cfg_apz_cmd2 = 1 then		state 	<= stValidateCh;				-- if "calibrate all" command, test next channel
																cmd_apv_sel <= cmd_apv_sel + 1;
						else									state 	<= stCmdDone;					-- otheriwise return to idle
						end if;
					-------------------------------------------------------------------------------------------------------	
					elsif state = stValidateCh then
						if cfg_apz_cmd2 /= 1 then			state 	<= stIdle;						-- command aborted
						elsif cmd_apv_sel(4) = '1' then	state 	<= stCmdDone;					-- channel > 15 -> finish
																	reset_after_cal <= '1';					-- FIX, APZ core is resetted after calibration, for some reson it hangs otherwise
						else	if cfg_evbld_chmask(conv_integer(cmd_apv_sel(3 downto 0))) = '1' then
																													-- if channel enabled in chmask 
									if cfg_apz_cmd1 = 2 then	state 	<= stPedCalib0;			--    ... go to pedestal calibration (bypass phase)
									else 								state 	<= stPhaseCalib;			--    ... go to phase calibration
									end if;
								else								cmd_apv_sel <= cmd_apv_sel + 1;		-- else test next channel
								end if;
						end if;
					-------------------------------------------------------------------------------------------------------	
					elsif state = stBypass then
						if cfg_apz_cmd /= 15 then			state 	<= stIdle;
--						if cfg_apz_cmd  =  0 then			state 	<= stIdle;
--						elsif cfg_apz_cmd /= 15 then		state 	<= stBypassEnd;		
						end if;
					-------------------------------------------------------------------------------------------------------	
--					elsif state = stBypassEnd then
--						if cfg_apz_cmd  =  0 then			state 	<= stIdle;
--						elsif counter > 5000 then			state 	<= stIdle;						-- wait for any event to finish
--						else 										counter := counter + 1; 	end if;
					-------------------------------------------------------------------------------------------------------	
					elsif state = stAPZReset then
						if cfg_apz_cmd /= x"ff" then		state 	<= stIdle;		end if;
						apz_chstatus <= (others => '0');
					-------------------------------------------------------------------------------------------------------	
					elsif state = stCmdDone then
						if cfg_apz_cmd /= cfg_apz_cmd_r then		state 	<= stIdle;		end if;		-- go to idle when command reg changes
					-------------------------------------------------------------------------------------------------------	
					else														state 	<= stIdle;						-- undefined state
					end if;
				end if;
			end if;
		end process;
		
		api_resync		 		<= '0' 		when state = stPhaseCalib			else '1';
		api_start_calib 		<= '1' 		when state = stPedCalib0			else '0';
		api_busy_out	 		<= '1' 		when state = stPedCalib1 or 
														  state = stFlushData or
														  cfg_apz_cmd2 = 1 				else '0';
		api_flush_data	 		<= x"FFFF" 	when state = stFlushData			else x"0000";
		evbld_apz_i		 		<= '0' 		when state = stBypass 
--														  or state = stBypassEnd 			
														  else '1';
--		api_trigger_inhibit 	<= '1' 		when state = stBypassEnd			else api_trigger_inhibit_i;

		reset_cmd		 		<= '1' 		when state = stAPZReset				else '0';
		cmd_done			 		<= '1' 		when state = stCmdDone				else '0';
		  
		api_apv_select_i  <= cmd_apv_sel(3 downto 0) when cfg_apz_cmd2 = 1 else cfg_apz_apvselect(3  downto 0 );
		apz_status        <= ( "0000" & cmd_apv_sel(3 downto 0) & 
										(not api_reset_i) 	& (not evbld_apz_i) 	& cmd_done 	& cmd_apv_sel(4) & 
										api_pedestal_wd_flag & api_phase_aligned 	& api_busy 	& api_trigger_inhibit_i );

        api_reset_i          <= ( ( (  not rstn )  or (not evbld_apz_i) )  or reset_cmd ) or reset_after_cal;
	end block; -- cmd_fsm_block
-------------------------------------------------------------------------------------------------------------------------------------------------------
        api_apv_select    <= api_apv_select_i;
        api_apv_mask      <= (  not cfg_evbld_chmask ) ;
        api_trigger_in    <= ( trigger and ( cfg_roenable(0 ) or api_random_trigger_i )  ) ;
		  api_read          <= api_read_in or api_flush_data;
--        api_I2C_done    <= '1';
        
        api_zs : APV_Interface_multi_wrap
            port map (
                I2C_ctr2          => api_I2C_ctr2,
                I2C_done          => api_I2C_done,
                I2C_request       => api_I2C_request,
                apv_data          => apv_data,
                apv_mask          => api_apv_mask,
                apv_select        => api_apv_select_i,
                busy              => api_busy,
                cfg_zs            => cfg_apz_zerosuppression,
                clk               => clk,
                clk10             => clk10M,
                clk125            => clk125,
                data_out          => api_data_out,
                filereg_apvselect => api_sigped_apv,
                load_pedestal     => api_load_pedestal,
                load_sigma        => api_load_sigma,
                n_samples         => api_n_samples,
                output_enable     => api_output_enable,
                pedestal_addr     => api_pedestal_addr,
                pedestal_in       => api_pedestal_in,
                pedestal_out      => api_pedestal_out,
                pedestal_wd_flag  => api_pedestal_wd_flag,
                phase_aligned     => api_phase_aligned,
                random_trigger    => api_random_trigger_i,
                read_in           => api_read,
                ready_out         => api_ready_out,
                reset             => api_reset_i,
                resync            => api_resync,
                sigma_addr        => api_sigma_addr,
                sigma_in          => api_sigma_in,
                sigma_out         => api_sigma_out,
                start_calib       => api_start_calib,
                trigger_in        => api_trigger_in,
                trigger_inhibit   => api_trigger_inhibit_i,
                wordcount_out     => api_wordcount_out
                );
			api_random_trigger 	<= api_random_trigger_i;
			api_trigger_inhibit 	<= api_trigger_inhibit_i;
--			api_busy_out			<= api_busy;
    end; 



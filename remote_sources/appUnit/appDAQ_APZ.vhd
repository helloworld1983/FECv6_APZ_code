--------------------------------------------------------------
--------------------------------------------------------------
--                                                          --
-- This VHDL file has been generated by the verilog2vhdl    --
-- tool.                                                    --
-- Contact help@edautils.com  for support/info.--
--                                                          --
--                                                          --
--------------------------------------------------------------
--------------------------------------------------------------
--
--
-- Assumptions: 
--         (1) All the parameters are of type INTEGER, and hence the translated generics are of this type
--
--
-- Generated by : smartoiu on 04/04/12 12:55
--
--

library ieee;
library work;
use ieee.std_logic_1164.all;
use IEEE.std_logic_unsigned.all;
use ieee.numeric_std.all;
use work.vhdl_functions_sc.all;

entity appDAQ_APZ_vhd is 
     port (
        clk :  in std_logic;
        clk125 :  in std_logic;
        clk10M :  in std_logic;
        rstn :  in std_logic;
	 -- ctrl
        evbld_apz :  in std_logic;
        api_reset :  in std_logic;
        cfg_roenable :  in std_logic_vector( 7  downto 0  );
        apv_select :  in std_logic_vector( 3  downto 0  );
	 -- trigger
        ro_trigger :  in std_logic;
		  trgID_FromSys : in std_logic_vector( 63  downto 0  );
	 -- ADC interface
        CH0 :  in std_logic_vector( 11  downto 0  );
        CH1 :  in std_logic_vector( 11  downto 0  );
        CH2 :  in std_logic_vector( 11  downto 0  );
        CH3 :  in std_logic_vector( 11  downto 0  );
        CH4 :  in std_logic_vector( 11  downto 0  );
        CH5 :  in std_logic_vector( 11  downto 0  );
        CH6 :  in std_logic_vector( 11  downto 0  );
        CH7 :  in std_logic_vector( 11  downto 0  );
        CH8 :  in std_logic_vector( 11  downto 0  );
        CH9 :  in std_logic_vector( 11  downto 0  );
        CH10 :  in std_logic_vector( 11  downto 0  );
        CH11 :  in std_logic_vector( 11  downto 0  );
        CH12 :  in std_logic_vector( 11  downto 0  );
        CH13 :  in std_logic_vector( 11  downto 0  );
        CH14 :  in std_logic_vector( 11  downto 0  );
        CH15 :  in std_logic_vector( 11  downto 0  );
	 -- APZ interface
        api_busy :  in std_logic;
        api_ready :  in std_logic_vector( 15  downto 0  );
        api_data :  in std_logic_vector( 255  downto 0  );
        api_wordcount :  in std_logic_vector( 255  downto 0  );
        api_read_out :  out std_logic_vector( 15  downto 0  );
		  api_output_enable : out std_logic_vector( 15  downto 0  );
	 -- tx interface
        txreq :  out std_logic;
        txdone :  out std_logic;
        txstart :  out std_logic;
        txstop :  out std_logic;
        txack :  in std_logic;
        txdstrdy :  in std_logic;
        txendframe :  in std_logic;
        txdata :  out std_logic_vector( 7  downto 0  );
        txlength :  out std_logic_vector( 15  downto 0  );
		  ro_NumFramesEvent :  out std_logic_vector( 6  downto 0  );
	 -- sc registers (app)
        regs :  in std_logic_vector( 1023  downto 0  )
    );
end entity; 


architecture rtl of appDAQ_APZ_vhd is 
-- eventbuild registers	declarations 
    signal cfg_evbld_mode, cfg_evbld_eventInfoType, cfg_evbld_eventInfoSwitch, cfg_evbld_eventInfoParams : std_logic_vector( 7  downto 0  );
    signal cfg_evbld_datalength, cfg_evbld_chmask : std_logic_vector( 15  downto 0  );
    signal cfg_evbld_eventInfoData, frameCounterOut : std_logic_vector( 31  downto 0  );
	 signal cfg_payload_bigendian : std_logic;
	 
    signal evbld_earlyStart, evbld_ren, evbld_nextchPointer_valid : std_logic;
    signal evbld_chPointer, evbld_nextchPointer : std_logic_vector( 3  downto 0  );
    signal apz_datalength : std_logic_vector( 15  downto 0  );
    signal evbld_rReady_apz : std_logic_vector( 15  downto 0  );
    signal apz_dataout : std_logic_vector( 7  downto 0  );
	 
    signal adc_data_in : std_logic_vector(191 downto 0);
    signal timestamp : std_logic_vector( 23  downto 0  );
    signal evbld_rAddr : std_logic_vector( 12  downto 0  );
    signal adc_dataout : std_logic_vector( 7  downto 0  );
    signal adc_chmask : std_logic_vector( 15  downto 0  );
    signal evbld_rReady_adc : std_logic_vector( 15  downto 0  );
    signal adc_datalength : std_logic_vector( 15  downto 0  );
    signal triggerID : std_logic_vector( 31  downto 0  );
    signal evbld_eventInfoData : std_logic_vector( 31  downto 0  );
	 
    signal cfg_evbld_eventInfoType_i : std_logic_vector( 7  downto 0  );
    signal cfg_evbld_chmask_i : std_logic_vector( 15  downto 0  );
    signal evbld_datalength, evbld_rReady: std_logic_vector( 15  downto 0  );
    signal evbld_data_in : std_logic_vector( 7  downto 0  );
    signal udpPauseData : std_logic;
    signal txstop_i : std_logic;
	 
	COMPONENT apz_data_switch
	PORT(
		clk : IN std_logic;
		reset : IN std_logic;
		bigendian : IN std_logic;
		chPointer : IN std_logic_vector(3 downto 0);
		nextchPointer : IN std_logic_vector(3 downto 0);
		nextchPointer_valid : IN std_logic;
		earlyStart : IN std_logic;
		data_in : IN std_logic_vector(255 downto 0);
		wordcount_in : IN std_logic_vector(255 downto 0);
		read_from_evbld : IN std_logic;          
		wordcount_out : OUT std_logic_vector(15 downto 0);
		data_out : OUT std_logic_vector(7 downto 0);
		read_to_apz : OUT std_logic_vector(15 downto 0)
		);
	END COMPONENT;
	COMPONENT adc_data_switch
	PORT(
		rstn : IN std_logic;
		clk : IN std_logic;
		eclk : IN std_logic;
		trgin : IN std_logic;
		enable : IN std_logic;
		bigendian : IN std_logic;
		data_in : IN std_logic_vector(191 downto 0);
		rAddr : IN std_logic_vector(12 downto 0);
		read_from_evbld : IN std_logic;
		rDone_from_evbld : IN std_logic;
		chSelect : IN std_logic_vector(3 downto 0);
		datalength : IN std_logic_vector(15 downto 0);
		eventInfoType : IN std_logic_vector(7 downto 0);          
		rReady_to_evbld : OUT std_logic_vector(15 downto 0);
		data_out : OUT std_logic_vector(7 downto 0);
		timestamp : OUT std_logic_vector(23 downto 0);
		datalength_to_evbld : OUT std_logic_vector(15 downto 0);
		chmask_out : OUT std_logic_vector(15 downto 0)
		);
	END COMPONENT;
	COMPONENT udpEventBuildAPZ
	PORT(
		clk : IN std_logic;
		rstn : IN std_logic;
		mode : IN std_logic_vector(7 downto 0);
		rReady : IN std_logic_vector(15 downto 0);
		timestamp : IN std_logic_vector(23 downto 0);
		data_in : IN std_logic_vector(7 downto 0);
		txack : IN std_logic;
		datalength : IN std_logic_vector(15 downto 0);
		eventInfoType : IN std_logic_vector(7 downto 0);
		eventInfoData : IN std_logic_vector(31 downto 0);
		udpPauseData : IN std_logic;
		frameEndEvent : IN std_logic;
		chmask : IN std_logic_vector(15 downto 0);          
		ren : OUT std_logic;
		chPointer_out : OUT std_logic_vector(3 downto 0);
		nextchPointer_out : OUT std_logic_vector(3 downto 0);
		earlyStart : OUT std_logic;
		nextchPointer_valid : OUT std_logic;
		rAddr : OUT std_logic_vector(12 downto 0);
		txreq : OUT std_logic;
		txdone : OUT std_logic;
		frameCounterOut : OUT std_logic_vector(31 downto 0);
		dataout : OUT std_logic_vector(7 downto 0);
		udpLength : OUT std_logic_vector(15 downto 0);
		udpStartTx : OUT std_logic;
		udpStopTx : OUT std_logic
		);
	END COMPONENT;
	COMPONENT bitsum15
	PORT(
		data : IN std_logic_vector(15 downto 0);          
		result : OUT std_logic_vector(6 downto 0)
		);
	END COMPONENT;

-----------------------------------------------------------------------------------------------
--	alias a_cfg_evbld_chmask : std_logic_vector(15 downto 0) is (regs and 8) ;
	
    begin 
-- eventbuild registers	 
        cfg_evbld_chmask 			<= ireg16( 8 , regs );
        cfg_evbld_datalength 		<= ireg16( 9 , regs );
        cfg_evbld_mode 				<= ireg8( 10 , regs );
        cfg_evbld_eventInfoType 	<= ireg8( 11 , regs );
--        cfg_evbld_eventInfoSwitch 	<= ireg8_any( 11 , 1, regs );
        cfg_evbld_eventInfoSwitch 	<= ireg8_any( 12 , 1, regs );   -- compatibility with ADC fw
        cfg_evbld_eventInfoParams 	<= ireg8_any( 11 , 2, regs );
        cfg_evbld_eventInfoData 	<= ireg32( 12 , regs );
		  
		  cfg_payload_bigendian <= cfg_evbld_eventInfoParams(0);
		  
        apz_data_switch_inst : apz_data_switch
            port map (
                clk                               => clk125,
                reset                             => api_reset,
                bigendian                         => cfg_payload_bigendian,
                chPointer                         => evbld_chPointer,
                data_in                           => api_data,
                data_out                          => apz_dataout,
                earlyStart                        => evbld_earlyStart,
                nextchPointer                     => evbld_nextchPointer,
                nextchPointer_valid               => evbld_nextchPointer_valid,
                read_from_evbld                   => evbld_ren,
                read_to_apz                       => api_read_out,
                wordcount_in                      => api_wordcount,
                wordcount_out                     => apz_datalength
                );
        api_output_enable <= X"FFFF" ;
-- mask calibration activity
        evbld_rReady_apz <= X"0000" when api_busy = '1' else ( api_ready or (  not cfg_evbld_chmask )  );
		  
	  adc_data_in <= CH8 & CH9 & CH10 & CH11 & CH12 & CH13 & CH14 & CH15 & CH0 & CH1 & CH2 & CH3 & CH4 & CH5 & CH6 & CH7	;	
	  adc_data_switch_inst : adc_data_switch
			port map (
				 chSelect => apv_select,
				 chmask_out => adc_chmask,
				 clk => clk,
				 data_in => adc_data_in,
				 data_out => adc_dataout,
				 datalength => cfg_evbld_datalength,
				 datalength_to_evbld => adc_datalength,
				 eclk => clk125,
				 enable => cfg_roenable(0 ),
				 bigendian => cfg_payload_bigendian,
				 eventInfoType => cfg_evbld_eventInfoType,
				 rAddr => evbld_rAddr,
				 rDone_from_evbld => txstop_i,
				 rReady_to_evbld => evbld_rReady_adc,
				 read_from_evbld => evbld_ren,
				 rstn => rstn,
				 timestamp => timestamp,
				 trgin => ro_trigger
				 );
				
-- trigger ID counter
        process (clk, rstn)
        begin
            if (  rstn = '0'  ) then 
                triggerID <= X"00000000" ;
            elsif clk'EVENT and ( clk = '1' ) then
                if ( ( cfg_roenable(0 ) = '0' )  ) then 
                    triggerID <= X"00000000" ;
                else 
                    if ( ( ro_trigger = '1' )  ) then 
                        triggerID <= ( triggerID + 1  ) ;
                    end if;
                end if;
            end if;
        end process;
		
--        evbld_eventInfoData <=  	( triggerID(15  downto 0 ) & cfg_evbld_datalength ) when ( cfg_evbld_eventInfoData(15  downto 8 ) = X"01"  ) else 
--											triggerID when ( cfg_evbld_eventInfoData(15  downto 8 ) = X"02"  ) else
--											( cfg_evbld_eventInfoData(31  downto 16 ) & cfg_evbld_datalength ) ;
        evbld_eventInfoData <=  	( triggerID(15  downto 0 ) & cfg_evbld_datalength ) 	when ( cfg_evbld_eventInfoSwitch = X"01"  ) else 
											triggerID 															when ( cfg_evbld_eventInfoSwitch = X"02"  ) else
											cfg_evbld_eventInfoData											when ( cfg_evbld_eventInfoSwitch = X"03"  ) else
											trgID_FromSys(31 downto 0)										when ( cfg_evbld_eventInfoSwitch = X"04"  ) else
											( cfg_evbld_eventInfoData(31  downto 16 ) & cfg_evbld_datalength ) ;
											
--------------------------/ eventbuild mux --------------------------------/
        cfg_evbld_eventInfoType_i 	<= X"02" 					when evbld_apz = '1' else X"00"  ;
        evbld_rReady 					<= evbld_rReady_apz 		when evbld_apz = '1' else evbld_rReady_adc ;
        evbld_data_in 					<= apz_dataout 			when evbld_apz = '1' else adc_dataout ;
        evbld_datalength 				<= apz_datalength 		when evbld_apz = '1' else adc_datalength ;
        cfg_evbld_chmask_i 			<= cfg_evbld_chmask 		when evbld_apz = '1' else adc_chmask ;
		  
--		  process(cfg_evbld_chmask_i)
--		  variable tmp: std_logic_vector (6 downto 0);
--		  begin
--				for i in 0 to 15 loop
--					tmp := tmp + cfg_evbld_chmask_i(i);
--				end loop;
--				ro_NumFramesEvent <= tmp;
--			end process;
			
--			ro_NumFramesEvent <= cfg_evbld_chmask_i(0) + cfg_evbld_chmask_i(1) + cfg_evbld_chmask_i(2) + cfg_evbld_chmask_i(3) + 
--										cfg_evbld_chmask_i(4) + cfg_evbld_chmask_i(5) + cfg_evbld_chmask_i(6) + cfg_evbld_chmask_i(7) + 
--										cfg_evbld_chmask_i(8) + cfg_evbld_chmask_i(9) + cfg_evbld_chmask_i(10) + cfg_evbld_chmask_i(11) + 
--										cfg_evbld_chmask_i(12) + cfg_evbld_chmask_i(13) + cfg_evbld_chmask_i(14) + cfg_evbld_chmask_i(15);
-- nothink of the above works !!!
	chmask_bitsum: bitsum15 PORT MAP(	data => cfg_evbld_chmask_i,	result => ro_NumFramesEvent);
		  
        udpPauseData <= (  not txdstrdy ) ;
        udpEventBuildAPZ_inst : udpEventBuildAPZ
            port map (
                rstn 				      => rstn,
                clk 					      => clk125,
                chPointer_out 	      => evbld_chPointer,
                chmask 				      => cfg_evbld_chmask_i,
                data_in 			      => evbld_data_in,
                datalength 		      => evbld_datalength,
                dataout 			      => txdata,
                earlyStart 		      => evbld_earlyStart,
                eventInfoData 	      => evbld_eventInfoData,
                eventInfoType 	      => cfg_evbld_eventInfoType_i,
                frameCounterOut 	      => frameCounterOut,
                frameEndEvent 	      => txendframe,
                mode 				      => cfg_evbld_mode,
                nextchPointer_out 		=> evbld_nextchPointer,
                nextchPointer_valid 	=> evbld_nextchPointer_valid,
                rAddr 				      => evbld_rAddr,
                rReady 				      => evbld_rReady,
                ren 					      => evbld_ren,
                timestamp 			      => timestamp,
                txack 				      => txack,
                txdone 				      => txdone,
                txreq 				      => txreq,
                udpLength 			      => txlength,
                udpPauseData 		      => udpPauseData,
                udpStartTx 		      => txstart,
                udpStopTx 			      => txstop_i
                );
					 
		 txstop <= txstop_i;
    end; 


